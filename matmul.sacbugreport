/**********************************************************************
 *
 * SAC bug report: matmul.sacbugreport
 *
 **********************************************************************
 *
 * Automatically generated on Tue 08 Oct 2024 10:19:19 AM CEST
 *
 * using sac2c 1.3.3-MijasCosta-1277-g23976
 * built 2024-10-08T09:24:08.
 * by user jordy on host jordy.
 *
 * The compiler was called by
 *  ../sac2c/build_d/sac2c_d -noprelude matmul.sac -b18
 *
 * The compiler crashed in
 *  phase: opt (Running SAC optimizations)
 *  sub phase: saacyc (Symbolic array attribute cycle 2)
 *  cycle phase: cse (Eliminating common subexpressions)
 *  cycle instance: 1
 *
 * What follows is the contents of matmul.sac.
 *
 **********************************************************************/

#ifndef P
#define P 1000
#endif

#ifndef ITER
#define ITER 100
#endif

inline double[d:shp] sel(int[n] idx, double[n:_,d:shp] a)
{
    return { iv -> _sel_VxA_(_cat_VxV_(idx, iv), a) | iv < shp };
}

inline double +(double a, double b) { return _add_SxS_(a, b); }

inline double sum(double[n] a)
{
    return with {
        ([0] <= iv < [n]): a[iv];
    } : fold(+, 0.0);
}

noinline double[u,w] matmul(double[u,v] a, double[v,w] b)
{
    return { [i,j] -> sum(_mul_VxV_(a[[i]], b[.,j])) };
}

int main()
{
    a = { [i,j] -> _tod_S_(i) | [i,j] < [P,P] };
    b = { [i,j] -> _tod_S_(j) | [i,j] < [P,P] };
    c = { iv -> 0.0 | iv < [P,P] };

    res = 0.0;

    for (i = 0; _le_SxS_(i, ITER); i = _add_SxS_(i, 1)) {
        c = _hideShape_SxA_(0, matmul(a, b));
        //res = _add_SxS_(res, _sel_VxA_([10,10], c));
    }

    return _toi_S_(_sel_VxA_([0,0], c));
}


/**********************************************************************
 *
 * End of bug report
 *
 **********************************************************************/

